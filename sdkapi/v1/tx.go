package v1

import (
	"bytes"
	"errors"
	"github.com/abesuite/abec/abecrypto"
	"github.com/abesuite/abec/abecrypto/abecryptoparam"
	"github.com/abesuite/abec/abeutil"
	"github.com/abesuite/abec/blockchain"
	"github.com/abesuite/abec/chainhash"
	"github.com/abesuite/abec/wire"
	"io"
)

// type OutPoint wire.OutPointAbe
//
//	As OutPointAbe use (TxHash, Index), here we use the more reasonable (TxId, Index)
//	In the future, we shall refactor OutPointAbe to (TxId, Index),
//	and here directly use "type OutPoint wire.OutPointAbe"
type OutPoint struct {
	TxId  *wire.TxId
	Index uint8

	outPointId *wire.OutPointId // cached OutPointId
}

func (outPoint *OutPoint) OutPointId() wire.OutPointId {
	if outPoint.outPointId == nil {
		// cache the outPointId

		opId := wire.OutPointId{}
		copy(opId[:], outPoint.TxId[:])
		opId[chainhash.HashSize] = outPoint.Index

		outPoint.outPointId = &opId
	}

	return *outPoint.outPointId
}

type TxRequestOutputDesc struct {
	cryptoAddress []byte // generated by CryptoAddressKeyGen
	value         uint64
}

type TxRequestInputDesc struct {
	ringId  *wire.RingId // txoRing identifier
	txoList []*wire.TxOutAbe
	sidx    uint8 // spend which one
}

type TransferTxRequestDesc struct {
	TxRequestInputDescs  []*TxRequestInputDesc
	TxRequestOutputDescs []*TxRequestOutputDesc
	Fee                  uint64
	TxMemo               []byte
}

type cryptoKey struct {
	cryptoAddress []byte // address, generated by CryptoAddressKeyGen
	cryptoSpsk    []byte // spend secret key, generated by CryptoAddressKeyGen
	cryptoSnsk    []byte //  serial-number secret key, generated by CryptoAddressKeyGen
	cryptoVsk     []byte //  view secret key, generated by CryptoAddressKeyGen
}

// todo: user gets TxId by RPC? here we need to be consistent with RPC? say,
// being chainHash.Hash or string
type TxId wire.TxId

// NewOutPointFromTxIdStr assumes the input txIdStr was obtained by "(hash chainHash.Hash) String()" function
func NewOutPointFromTxIdStr(txIdStr string, index uint8) (*OutPoint, error) {
	txHash, err := chainhash.NewHashFromStr(txIdStr)
	if err != nil {
		return nil, err
	}

	txId := wire.TxId(*txHash)

	return &OutPoint{
		TxId:  &txId,
		Index: index,
	}, nil
}

func NewTxRequestOutputDesc(cryptoAddress []byte, value uint64) *TxRequestOutputDesc {
	return &TxRequestOutputDesc{
		cryptoAddress: cryptoAddress,
		value:         value,
	}
}

func (txRequestInputDesc *TxRequestInputDesc) serializeSize() int {
	n := 0

	//	ringId
	n += chainhash.HashSize

	//	txoList
	ringSize := len(txRequestInputDesc.txoList)
	n += VarIntSerializeSize(uint64(ringSize))
	for i := 0; i < ringSize; i++ {
		n += txRequestInputDesc.txoList[i].SerializeSize()
	}

	// sidx
	n += 1

	return n
}

func writeTxRequestInputDesc(w io.Writer, txRequestInputDesc *TxRequestInputDesc) error {
	//	ringId
	_, err := w.Write(txRequestInputDesc.ringId[:])
	if err != nil {
		return err
	}

	//	txoList
	err = WriteVarInt(w, uint64(len(txRequestInputDesc.txoList)))
	if err != nil {
		return err
	}
	for _, txOut := range txRequestInputDesc.txoList {
		err = wire.WriteTxOutAbe(w, 0, txOut.Version, txOut)
		if err != nil {
			return err
		}
	}

	//	sidx
	err = binarySerializer.PutUint8(w, txRequestInputDesc.sidx)
	if err != nil {
		return err
	}

	return nil
}

func readTxRequestInputDesc(r io.Reader, txRequestInputDesc *TxRequestInputDesc) error {
	//	ringId
	ringId := wire.RingId{}
	_, err := io.ReadFull(r, ringId[:])
	if err != nil {
		return err
	}

	// TxOuts
	txoNum, err := ReadVarInt(r)
	if err != nil {
		return err
	}
	txoList := make([]*wire.TxOutAbe, txoNum)
	for i := uint64(0); i < txoNum; i++ {
		txOut := wire.TxOutAbe{}
		err = wire.ReadTxOutAbe(r, 0, 0, &txOut)
		if err != nil {
			return err
		}
		txoList[i] = &txOut
	}

	// sidx
	sidx, err := binarySerializer.Uint8(r)
	if err != nil {
		return err
	}

	txRequestInputDesc.ringId = &ringId
	txRequestInputDesc.txoList = txoList
	txRequestInputDesc.sidx = sidx

	return nil
}

func (txRequestOutputDesc *TxRequestOutputDesc) serializeSize() int {
	n := 0
	//	cryptoAddress
	cryptoAddressLen := len(txRequestOutputDesc.cryptoAddress)
	n += VarIntSerializeSize(uint64(cryptoAddressLen)) + cryptoAddressLen

	//	value
	n += VarIntSerializeSize(txRequestOutputDesc.value)

	return n
}

func writeTxRequestOutputDesc(w io.Writer, txRequestOutputDesc *TxRequestOutputDesc) error {

	//	cryptoAddress
	err := WriteVarBytes(w, txRequestOutputDesc.cryptoAddress)
	if err != nil {
		return err
	}

	//	value
	err = WriteVarInt(w, txRequestOutputDesc.value)
	if err != nil {
		return err
	}

	return nil
}

func readTxRequestOutputDesc(r io.Reader, txRequestOutputDesc *TxRequestOutputDesc) error {

	//	cryptoAddress
	cryptoAddress, err := ReadVarBytes(r, abecrypto.GetCryptoAddressSerializeSizeMax(), "TxRequestOutputDesc.CryptoAddress")
	if err != nil {
		return err
	}

	//	value
	value, err := ReadVarInt(r)
	if err != nil {
		return err
	}

	txRequestOutputDesc.cryptoAddress = cryptoAddress
	txRequestOutputDesc.value = value

	return nil
}

func (txRequestDesc *TransferTxRequestDesc) serializeSize() int {
	n := 0

	//	TxRequestInputDescs
	inputNum := len(txRequestDesc.TxRequestInputDescs)
	n += VarIntSerializeSize(uint64(inputNum))
	for i := 0; i < inputNum; i++ {
		n += txRequestDesc.TxRequestInputDescs[i].serializeSize()
	}

	//  TxRequestOutputDescs
	outputNum := len(txRequestDesc.TxRequestOutputDescs)
	n += VarIntSerializeSize(uint64(outputNum))
	for i := 0; i < outputNum; i++ {
		n += txRequestDesc.TxRequestOutputDescs[i].serializeSize()
	}

	//	Fee
	n += VarIntSerializeSize(txRequestDesc.Fee)

	//	TxMemo
	memoLen := len(txRequestDesc.TxMemo)
	n += VarIntSerializeSize(uint64(memoLen)) + memoLen

	return n
}

func serializeTransferTxRequestDesc(txRequestDesc *TransferTxRequestDesc) ([]byte, error) {
	if txRequestDesc == nil {
		return nil, errors.New("serializeTransferTxRequestDesc: input txRequestDesc is nil")
	}

	w := bytes.NewBuffer(make([]byte, 0, txRequestDesc.serializeSize()))

	//	TxRequestInputDescs
	inputNum := len(txRequestDesc.TxRequestInputDescs)
	err := WriteVarInt(w, uint64(inputNum))
	if err != nil {
		return nil, err
	}
	for i := 0; i < inputNum; i++ {
		err = writeTxRequestInputDesc(w, txRequestDesc.TxRequestInputDescs[i])
		if err != nil {
			return nil, err
		}
	}

	//  TxRequestOutputDescs
	outputNum := len(txRequestDesc.TxRequestOutputDescs)
	err = WriteVarInt(w, uint64(outputNum))
	for i := 0; i < outputNum; i++ {
		err = writeTxRequestOutputDesc(w, txRequestDesc.TxRequestOutputDescs[i])
		if err != nil {
			return nil, err
		}
	}

	//	Fee
	err = WriteVarInt(w, txRequestDesc.Fee)
	if err != nil {
		return nil, err
	}

	//	TxMemo
	err = WriteVarBytes(w, txRequestDesc.TxMemo)
	if err != nil {
		return nil, err
	}

	return w.Bytes(), nil
}

func deserializeTransferTxRequestDesc(serializedTxRequestDesc []byte) (*TransferTxRequestDesc, error) {
	var err error
	var count uint64

	r := bytes.NewReader(serializedTxRequestDesc)

	// Inputs     []*TxRequestInputDesc
	var Inputs []*TxRequestInputDesc
	count, err = ReadVarInt(r)
	if err != nil {
		return nil, err
	}
	if count != 0 {
		Inputs = make([]*TxRequestInputDesc, count)
		for i := uint64(0); i < count; i++ {
			txRequestInputDesc := TxRequestInputDesc{}
			err = readTxRequestInputDesc(r, &txRequestInputDesc)
			if err != nil {
				return nil, err
			}
			Inputs[i] = &txRequestInputDesc
		}
	} else {
		Inputs = nil
	}

	// Outputs []*TxRequestOutputDesc
	var Outputs []*TxRequestOutputDesc
	count, err = ReadVarInt(r)
	if err != nil {
		return nil, err
	}
	if count != 0 {
		Outputs = make([]*TxRequestOutputDesc, count)
		for i := uint64(0); i < count; i++ {
			txRequestOutputDesc := TxRequestOutputDesc{}
			err = readTxRequestOutputDesc(r, &txRequestOutputDesc)
			if err != nil {
				return nil, err
			}
		}
	} else {
		Outputs = nil
	}

	// Fee        uint64
	Fee, err := ReadVarInt(r)
	if err != nil {
		return nil, err
	}

	// TxMemo []byte
	TxMemo, err := ReadVarBytes(r, abecryptoparam.MaxAllowedTxMemoSize, "TransferTxRequestDesc.TxMemo")
	if err != nil {
		return nil, err
	}

	return &TransferTxRequestDesc{
		TxRequestInputDescs:  Inputs,
		TxRequestOutputDescs: Outputs,
		Fee:                  Fee,
		TxMemo:               TxMemo,
	}, nil
}

func BuildTransferTxRequestDesc(outPointsToSpend []*OutPoint, serializedBlocksForRingGroup [][]byte, txRequestOutputDescs []*TxRequestOutputDesc, fee uint64, txMemo []byte) (serializedTxRequestDesc []byte, err error) {
	inputNum := len(outPointsToSpend)
	if inputNum == 0 {
		return nil, errors.New("BuildTransferTxRequestDesc: input outPointsToSpend is empty")
	}

	outputNum := len(txRequestOutputDescs)
	if outputNum == 0 {
		return nil, errors.New("BuildTransferTxRequestDesc: input txRequestOutputDescs is empty")
	}

	blockNum := len(serializedBlocksForRingGroup)

	if blockNum == 0 {
		return nil, errors.New("BuildTransferTxRequestDesc: input serializedBlocksForRingGroup is empty")
	}

	blocks := make([]*abeutil.BlockAbe, blockNum)
	for i := 0; i < blockNum; i++ {
		// todo: to confirm
		//	For example, in the function, blockNoWitness is used.
		//	We need to clarify these functions.
		blocks[i], err = abeutil.NewBlockFromBytesAbe(serializedBlocksForRingGroup[i])
		if err != nil {
			return nil, err
		}

		//	assume the blocks are valid blocks in ledger, include:
		// (1) the Header contains its height. Based on this, we explicitly set the height of Block.
		blocks[i].SetHeight(blocks[i].MsgBlock().Header.Height)
	}

	startBlockHeight := blocks[0].Height()
	blockNumPerRingGroup := wire.GetTxoRingSizeByBlockHeight(startBlockHeight)
	ringSize := wire.GetTxoRingSizeByBlockHeight(startBlockHeight)

	for i := 1; i < blockNum; i++ {
		height := blocks[i].Height()
		if height != startBlockHeight+int32(i) {
			return nil, errors.New("BuildTransferTxRequestDesc: the heights of input serializedBlocksForRingGroup are not successive")
		}

		if wire.GetTxoRingSizeByBlockHeight(height) != blockNumPerRingGroup {
			return nil, errors.New("BuildTransferTxRequestDesc: input serializedBlocksForRingGroup imply different blockNumPerRingGroup")
		}

		if wire.GetTxoRingSizeByBlockHeight(height) != ringSize {
			return nil, errors.New("BuildTransferTxRequestDesc: input serializedBlocksForRingGroup imply different RingSize")
		}
	}

	if blockNum%int(blockNumPerRingGroup) != 0 {
		return nil, errors.New("BuildTransferTxRequestDesc: the blocks in input serializedBlocksForRingGroup cannot be divided into groups completely")
	}

	txRequestInputDescs := make([]*TxRequestInputDesc, inputNum)

	outPointToTxRequestInputDescMap := make(map[wire.OutPointId]*TxRequestInputDesc, inputNum)
	for i := 0; i < inputNum; i++ {
		txRequestInputDescs[i] = &TxRequestInputDesc{ringId: nil}
		// this nil will be used to check whether the corresponding TxoRing

		outPoint := *outPointsToSpend[i]
		opId := outPoint.OutPointId()
		if _, ok := outPointToTxRequestInputDescMap[opId]; ok {
			return nil, errors.New("BuildTransferTxRequestDesc: outPointsToSpend contains repeated OutPoint")
		} else {
			outPointToTxRequestInputDescMap[opId] = txRequestInputDescs[i]
			//	later txRequestInputDescs[i] will be fetched from the map, then be set and put back
		}
	}

	groupNum := blockNum % int(blockNumPerRingGroup)
	for i := 0; i < groupNum; i++ {
		txoRings, err := blockchain.BuildTxoRings(int(blockNumPerRingGroup), int(ringSize), blocks[i*int(blockNumPerRingGroup):(i+1)*int(blockNumPerRingGroup)])
		if err != nil {
			return nil, err
		}

		for ringId, txoRing := range txoRings {
			for opIndex, outPoint := range txoRing.OutPointRing().OutPoints {
				opId := outPoint.OutPointId()
				if txRequestInputDesc, ok := outPointToTxRequestInputDescMap[opId]; ok {
					//	the outPoint is one of the outPointsToSpend
					if txRequestInputDesc.ringId != nil {
						// It has been set previously
						return nil, errors.New("BuildTransferTxRequestDesc: there are repeated OutPoint (TxId, Index) in the rings")
					}

					txRequestInputDesc.ringId = &ringId
					txRequestInputDesc.txoList = txoRing.TxOuts()
					txRequestInputDesc.sidx = uint8(opIndex) //	The Ring Rule will makes sure opIndex is in the scope of uint8

					//	to be safe, put txRequestInputDesc back
					outPointToTxRequestInputDescMap[opId] = txRequestInputDesc
				}
			}
		}
	}

	//	check whether all outPoint has find the corresponding TxoRing
	for i := 0; i < inputNum; i++ {
		if txRequestInputDescs[i].ringId == nil {
			return nil, errors.New("BuildTransferTxRequestDesc: at least one of the input OutPoing can not find the corresponding TxoRing")
		}
	}

	trTxRequestDesc := &TransferTxRequestDesc{
		TxRequestInputDescs:  txRequestInputDescs,
		TxRequestOutputDescs: txRequestOutputDescs,
		Fee:                  fee,
		TxMemo:               txMemo,
	}

	serialzedTxRequestDesc, err := serializeTransferTxRequestDesc(trTxRequestDesc)
	if err != nil {
		return nil, err
	}

	return serialzedTxRequestDesc, nil
}

// todo: serializedMsgTx?
func GenerateTransferTx(serializedTransferTxRequestDesc []byte, cryptoKeys []*cryptoKey) (serializedTx []byte, txId *TxId) {
	return nil, nil
}
