package v1

import (
	"bytes"
	"errors"
	"fmt"
	"github.com/abesuite/abec/abecrypto"
	"github.com/abesuite/abec/abecrypto/abecryptoparam"
	"github.com/abesuite/abec/abeutil"
	"github.com/abesuite/abec/blockchain"
	"github.com/abesuite/abec/chainhash"
	"github.com/abesuite/abec/wire"
	"io"
)

// type OutPoint wire.OutPointAbe
//
//	As OutPointAbe use (TxHash, Index), here we use the more reasonable (TxId, Index)
//	In the future, we shall refactor OutPointAbe to (TxId, Index),
//	and here directly use "type OutPoint wire.OutPointAbe"
type OutPoint struct {
	TxId  *wire.TxId
	Index uint8

	outPointId *wire.OutPointId // cached OutPointId
}

func (outPoint *OutPoint) OutPointId() wire.OutPointId {
	if outPoint.outPointId == nil {
		// cache the outPointId

		opId := wire.OutPointId{}
		copy(opId[:], outPoint.TxId[:])
		opId[chainhash.HashSize] = outPoint.Index

		outPoint.outPointId = &opId
	}

	return *outPoint.outPointId
}

type TxRequestOutputDesc struct {
	cryptoAddress []byte // generated by CryptoAddressKeyGen
	value         uint64
}

type TxRequestInputDesc struct {
	ringId *wire.RingId // txoRing identifier
	//txoList []*wire.TxOutAbe
	txoRing *blockchain.TxoRing
	sidx    uint8 // spend which one
}

type TransferTxRequestDesc struct {
	TxRequestInputDescs  []*TxRequestInputDesc
	TxRequestOutputDescs []*TxRequestOutputDesc
	TxFee                uint64
	TxMemo               []byte
}

type CryptoKey struct {
	cryptoAddress []byte // address, generated by CryptoAddressKeyGen
	cryptoSpsk    []byte // spend secret key, generated by CryptoAddressKeyGen
	cryptoSnsk    []byte //  serial-number secret key, generated by CryptoAddressKeyGen
	cryptoVsk     []byte //  view secret key, generated by CryptoAddressKeyGen
}

// todo: user gets TxId by RPC? here we need to be consistent with RPC? say,
// being chainHash.Hash or string
type TxId wire.TxId

// NewOutPointFromTxIdStr assumes the input txIdStr was obtained by "(hash chainHash.Hash) String()" function
func NewOutPointFromTxIdStr(txIdStr string, index uint8) (*OutPoint, error) {
	txHash, err := chainhash.NewHashFromStr(txIdStr)
	if err != nil {
		return nil, err
	}

	txId := wire.TxId(*txHash)

	return &OutPoint{
		TxId:  &txId,
		Index: index,
	}, nil
}

func NewTxRequestOutputDesc(cryptoAddress []byte, value uint64) *TxRequestOutputDesc {
	return &TxRequestOutputDesc{
		cryptoAddress: cryptoAddress,
		value:         value,
	}
}

func NewCryptoKey(cryptoAddress []byte, cryptoSpsk []byte, cryptoSnsk []byte, cryptoVsk []byte) *CryptoKey {
	return &CryptoKey{
		cryptoAddress: cryptoAddress,
		cryptoSpsk:    cryptoSpsk,
		cryptoSnsk:    cryptoSnsk,
		cryptoVsk:     cryptoVsk,
	}
}

func (txRequestInputDesc *TxRequestInputDesc) serializeSize() int {
	n := 0

	//	ringId
	n += chainhash.HashSize

	////	txoList
	//ringSize := len(txRequestInputDesc.txoList)
	//n += VarIntSerializeSize(uint64(ringSize))
	//for i := 0; i < ringSize; i++ {
	//	n += txRequestInputDesc.txoList[i].SerializeSize()
	//}

	//	txoRing
	n += txRequestInputDesc.txoRing.SerializeSize()

	// sidx
	n += 1

	return n
}

func writeTxRequestInputDesc(w io.Writer, txRequestInputDesc *TxRequestInputDesc) error {
	//	ringId
	_, err := w.Write(txRequestInputDesc.ringId[:])
	if err != nil {
		return err
	}

	////	txoList
	//err = WriteVarInt(w, uint64(len(txRequestInputDesc.txoList)))
	//if err != nil {
	//	return err
	//}
	//for _, txOut := range txRequestInputDesc.txoList {
	//	err = wire.WriteTxOutAbe(w, 0, txOut.Version, txOut)
	//	if err != nil {
	//		return err
	//	}
	//}

	//	txoRing
	err = txRequestInputDesc.txoRing.Serialize(w)
	if err != nil {
		return err
	}

	//	sidx
	err = binarySerializer.PutUint8(w, txRequestInputDesc.sidx)
	if err != nil {
		return err
	}

	return nil
}

func readTxRequestInputDesc(r io.Reader, txRequestInputDesc *TxRequestInputDesc) error {
	//	ringId
	ringId := wire.RingId{}
	_, err := io.ReadFull(r, ringId[:])
	if err != nil {
		return err
	}

	//// TxOuts
	//txoNum, err := ReadVarInt(r)
	//if err != nil {
	//	return err
	//}
	//txoList := make([]*wire.TxOutAbe, txoNum)
	//for i := uint64(0); i < txoNum; i++ {
	//	txOut := wire.TxOutAbe{}
	//	err = wire.ReadTxOutAbe(r, 0, 0, &txOut)
	//	if err != nil {
	//		return err
	//	}
	//	txoList[i] = &txOut
	//}

	//	txoRing
	txoRing := &blockchain.TxoRing{}
	err = txoRing.Deserialize(r)
	if err != nil {
		return err
	}

	// sidx
	sidx, err := binarySerializer.Uint8(r)
	if err != nil {
		return err
	}

	txRequestInputDesc.ringId = &ringId
	txRequestInputDesc.txoRing = txoRing
	txRequestInputDesc.sidx = sidx

	return nil
}

func (txRequestOutputDesc *TxRequestOutputDesc) serializeSize() int {
	n := 0
	//	cryptoAddress
	cryptoAddressLen := len(txRequestOutputDesc.cryptoAddress)
	n += VarIntSerializeSize(uint64(cryptoAddressLen)) + cryptoAddressLen

	//	value
	n += VarIntSerializeSize(txRequestOutputDesc.value)

	return n
}

func writeTxRequestOutputDesc(w io.Writer, txRequestOutputDesc *TxRequestOutputDesc) error {

	//	cryptoAddress
	err := WriteVarBytes(w, txRequestOutputDesc.cryptoAddress)
	if err != nil {
		return err
	}

	//	value
	err = WriteVarInt(w, txRequestOutputDesc.value)
	if err != nil {
		return err
	}

	return nil
}

func readTxRequestOutputDesc(r io.Reader, txRequestOutputDesc *TxRequestOutputDesc) error {

	//	cryptoAddress
	cryptoAddress, err := ReadVarBytes(r, abecrypto.GetCryptoAddressSerializeSizeMax(), "TxRequestOutputDesc.CryptoAddress")
	if err != nil {
		return err
	}

	//	value
	value, err := ReadVarInt(r)
	if err != nil {
		return err
	}

	txRequestOutputDesc.cryptoAddress = cryptoAddress
	txRequestOutputDesc.value = value

	return nil
}

func (txRequestDesc *TransferTxRequestDesc) serializeSize() int {
	n := 0

	//	TxRequestInputDescs
	inputNum := len(txRequestDesc.TxRequestInputDescs)
	n += VarIntSerializeSize(uint64(inputNum))
	for i := 0; i < inputNum; i++ {
		n += txRequestDesc.TxRequestInputDescs[i].serializeSize()
	}

	//  TxRequestOutputDescs
	outputNum := len(txRequestDesc.TxRequestOutputDescs)
	n += VarIntSerializeSize(uint64(outputNum))
	for i := 0; i < outputNum; i++ {
		n += txRequestDesc.TxRequestOutputDescs[i].serializeSize()
	}

	//	TxFee
	n += VarIntSerializeSize(txRequestDesc.TxFee)

	//	TxMemo
	memoLen := len(txRequestDesc.TxMemo)
	n += VarIntSerializeSize(uint64(memoLen)) + memoLen

	return n
}

func serializeTransferTxRequestDesc(txRequestDesc *TransferTxRequestDesc) ([]byte, error) {
	if txRequestDesc == nil {
		return nil, errors.New("serializeTransferTxRequestDesc: input txRequestDesc is nil")
	}

	w := bytes.NewBuffer(make([]byte, 0, txRequestDesc.serializeSize()))

	//	TxRequestInputDescs
	inputNum := len(txRequestDesc.TxRequestInputDescs)
	err := WriteVarInt(w, uint64(inputNum))
	if err != nil {
		return nil, err
	}
	for i := 0; i < inputNum; i++ {
		err = writeTxRequestInputDesc(w, txRequestDesc.TxRequestInputDescs[i])
		if err != nil {
			return nil, err
		}
	}

	//  TxRequestOutputDescs
	outputNum := len(txRequestDesc.TxRequestOutputDescs)
	err = WriteVarInt(w, uint64(outputNum))
	for i := 0; i < outputNum; i++ {
		err = writeTxRequestOutputDesc(w, txRequestDesc.TxRequestOutputDescs[i])
		if err != nil {
			return nil, err
		}
	}

	//	TxFee
	err = WriteVarInt(w, txRequestDesc.TxFee)
	if err != nil {
		return nil, err
	}

	//	TxMemo
	err = WriteVarBytes(w, txRequestDesc.TxMemo)
	if err != nil {
		return nil, err
	}

	return w.Bytes(), nil
}

func deserializeTransferTxRequestDesc(serializedTxRequestDesc []byte) (*TransferTxRequestDesc, error) {
	var err error
	var count uint64

	r := bytes.NewReader(serializedTxRequestDesc)

	// Inputs     []*TxRequestInputDesc
	var Inputs []*TxRequestInputDesc
	count, err = ReadVarInt(r)
	if err != nil {
		return nil, err
	}
	if count != 0 {
		Inputs = make([]*TxRequestInputDesc, count)
		for i := uint64(0); i < count; i++ {
			txRequestInputDesc := TxRequestInputDesc{}
			err = readTxRequestInputDesc(r, &txRequestInputDesc)
			if err != nil {
				return nil, err
			}
			Inputs[i] = &txRequestInputDesc
		}
	} else {
		Inputs = nil
	}

	// Outputs []*TxRequestOutputDesc
	var Outputs []*TxRequestOutputDesc
	count, err = ReadVarInt(r)
	if err != nil {
		return nil, err
	}
	if count != 0 {
		Outputs = make([]*TxRequestOutputDesc, count)
		for i := uint64(0); i < count; i++ {
			txRequestOutputDesc := TxRequestOutputDesc{}
			err = readTxRequestOutputDesc(r, &txRequestOutputDesc)
			if err != nil {
				return nil, err
			}
		}
	} else {
		Outputs = nil
	}

	// Fee        uint64
	TxFee, err := ReadVarInt(r)
	if err != nil {
		return nil, err
	}

	// TxMemo []byte
	TxMemo, err := ReadVarBytes(r, abecryptoparam.MaxAllowedTxMemoSize, "TransferTxRequestDesc.TxMemo")
	if err != nil {
		return nil, err
	}

	return &TransferTxRequestDesc{
		TxRequestInputDescs:  Inputs,
		TxRequestOutputDescs: Outputs,
		TxFee:                TxFee,
		TxMemo:               TxMemo,
	}, nil
}

func BuildTransferTxRequestDescFromTxoRings(outPointsToSpend []*OutPoint, serializedTxoRings [][]byte, txRequestOutputDescs []*TxRequestOutputDesc, txFee uint64, txMemo []byte) (serializedTxRequestDesc []byte, err error) {
	panic("implement me")
	return nil, nil
}

func BuildTransferTxRequestDescFromBlocks(outPointsToSpend []*OutPoint, serializedBlocksForRingGroup [][]byte, txRequestOutputDescs []*TxRequestOutputDesc, txFee uint64, txMemo []byte) (serializedTxRequestDesc []byte, err error) {
	inputNum := len(outPointsToSpend)
	if inputNum == 0 {
		return nil, errors.New("BuildTransferTxRequestDesc: input outPointsToSpend is empty")
	}

	outputNum := len(txRequestOutputDescs)
	if outputNum == 0 {
		return nil, errors.New("BuildTransferTxRequestDesc: input txRequestOutputDescs is empty")
	}

	blockNum := len(serializedBlocksForRingGroup)

	if blockNum == 0 {
		return nil, errors.New("BuildTransferTxRequestDesc: input serializedBlocksForRingGroup is empty")
	}

	blocks := make([]*abeutil.BlockAbe, blockNum)
	for i := 0; i < blockNum; i++ {
		// todo: to confirm
		//	For example, in the function, blockNoWitness is used.
		//	We need to clarify these functions.
		blocks[i], err = abeutil.NewBlockFromBytesAbe(serializedBlocksForRingGroup[i])
		if err != nil {
			return nil, err
		}

		//	assume the blocks are valid blocks in ledger, include:
		// (1) the Header contains its height. Based on this, we explicitly set the height of Block.
		blocks[i].SetHeight(blocks[i].MsgBlock().Header.Height)
	}

	startBlockHeight := blocks[0].Height()
	blockNumPerRingGroup := wire.GetTxoRingSizeByBlockHeight(startBlockHeight)
	ringSize := wire.GetTxoRingSizeByBlockHeight(startBlockHeight)

	for i := 1; i < blockNum; i++ {
		height := blocks[i].Height()
		if height != startBlockHeight+int32(i) {
			return nil, errors.New("BuildTransferTxRequestDesc: the heights of input serializedBlocksForRingGroup are not successive")
		}

		if wire.GetTxoRingSizeByBlockHeight(height) != blockNumPerRingGroup {
			return nil, errors.New("BuildTransferTxRequestDesc: input serializedBlocksForRingGroup imply different blockNumPerRingGroup")
		}

		if wire.GetTxoRingSizeByBlockHeight(height) != ringSize {
			return nil, errors.New("BuildTransferTxRequestDesc: input serializedBlocksForRingGroup imply different RingSize")
		}
	}

	if blockNum%int(blockNumPerRingGroup) != 0 {
		return nil, errors.New("BuildTransferTxRequestDesc: the blocks in input serializedBlocksForRingGroup cannot be divided into groups completely")
	}

	txRequestInputDescs := make([]*TxRequestInputDesc, inputNum)

	outPointToTxRequestInputDescMap := make(map[wire.OutPointId]*TxRequestInputDesc, inputNum)
	for i := 0; i < inputNum; i++ {
		txRequestInputDescs[i] = &TxRequestInputDesc{ringId: nil}
		// this nil will be used to check whether the corresponding TxoRing

		outPoint := *outPointsToSpend[i]
		opId := outPoint.OutPointId()
		if _, ok := outPointToTxRequestInputDescMap[opId]; ok {
			return nil, errors.New("BuildTransferTxRequestDesc: outPointsToSpend contains repeated OutPoint")
		} else {
			outPointToTxRequestInputDescMap[opId] = txRequestInputDescs[i]
			//	later txRequestInputDescs[i] will be fetched from the map, then be set and put back
		}
	}

	groupNum := blockNum % int(blockNumPerRingGroup)
	for i := 0; i < groupNum; i++ {
		txoRings, err := blockchain.BuildTxoRings(int(blockNumPerRingGroup), int(ringSize), blocks[i*int(blockNumPerRingGroup):(i+1)*int(blockNumPerRingGroup)])
		if err != nil {
			return nil, err
		}

		for ringId, txoRing := range txoRings {
			for opIndex, outPoint := range txoRing.OutPointRing().OutPoints {
				opId := outPoint.OutPointId()
				if txRequestInputDesc, ok := outPointToTxRequestInputDescMap[opId]; ok {
					//	the outPoint is one of the outPointsToSpend
					if txRequestInputDesc.ringId != nil {
						// It has been set previously
						return nil, errors.New("BuildTransferTxRequestDesc: there are repeated OutPoint (TxId, Index) in the rings")
					}

					txRequestInputDesc.ringId = &ringId
					txRequestInputDesc.txoRing = txoRing
					txRequestInputDesc.sidx = uint8(opIndex) //	The Ring Rule will makes sure opIndex is in the scope of uint8

					//	to be safe, put txRequestInputDesc back
					outPointToTxRequestInputDescMap[opId] = txRequestInputDesc
				}
			}
		}
	}

	//	check whether all outPoint has found the corresponding TxoRing
	for i := 0; i < inputNum; i++ {
		if txRequestInputDescs[i].ringId == nil {
			return nil, errors.New("BuildTransferTxRequestDesc: at least one of the input OutPoing can not find the corresponding TxoRing")
		}
	}

	trTxRequestDesc := &TransferTxRequestDesc{
		TxRequestInputDescs:  txRequestInputDescs,
		TxRequestOutputDescs: txRequestOutputDescs,
		TxFee:                txFee,
		TxMemo:               txMemo,
	}

	serialzedTxRequestDesc, err := serializeTransferTxRequestDesc(trTxRequestDesc)
	if err != nil {
		return nil, err
	}

	return serialzedTxRequestDesc, nil
}

func CreateTransferTx(serializedTransferTxRequestDesc []byte, cryptoKeys []*CryptoKey) (serializedTxFull []byte, txId *TxId, err error) {

	txRequestDesc, err := deserializeTransferTxRequestDesc(serializedTransferTxRequestDesc)
	if err != nil {
		return nil, nil, err
	}

	// abeTxInputDescs []*AbeTxInputDesc
	//	sanity checks
	inputNum := len(txRequestDesc.TxRequestInputDescs)
	if inputNum != len(cryptoKeys) {
		return nil, nil, errors.New("GenerateTransferTx: the number of input keys does not mathc the number of TransferTxRequestDesc's inputs")
	}

	abeTxInputDescs := make([]*abecrypto.AbeTxInputDesc, inputNum)
	for i := 0; i < inputNum; i++ {
		txRequestInputDesc := txRequestDesc.TxRequestInputDescs[i]
		cryptoKey := cryptoKeys[i]

		//	key validity check
		if valid, hints := abecrypto.VerifyCryptoAddressKey(cryptoKey.cryptoAddress, cryptoKey.cryptoSpsk, cryptoKey.cryptoSnsk, cryptoKey.cryptoVsk); !valid {
			return nil, nil, errors.New(hints)
		}

		ok, value, err := abecrypto.TxoCoinReceive(txRequestInputDesc.txoRing.TxOuts()[txRequestInputDesc.sidx], cryptoKey.cryptoAddress, cryptoKey.cryptoVsk)
		if err != nil {
			return nil, nil, err
		}
		if !ok {
			errStr := fmt.Sprintf("the %d -th cryptoKey cannot extract coin-value from the corresponding TxRequestInputDesc", i)
			return nil, nil, errors.New(errStr)
		}

		abeTxInputDescs[i] = abecrypto.NewAbeTxInputDescWithFullRing(txRequestInputDesc.ringId, txRequestInputDesc.txoRing, txRequestInputDesc.sidx, cryptoKey.cryptoAddress, cryptoKey.cryptoSpsk, cryptoKey.cryptoSnsk, cryptoKey.cryptoVsk, value)
	}

	//	abeTxOutputDescs []*AbeTxOutputDesc
	outputNum := len(txRequestDesc.TxRequestOutputDescs)
	abeTxOutputDescs := make([]*abecrypto.AbeTxOutputDesc, outputNum)
	for i := 0; i < outputNum; i++ {
		txRequestOutputDesc := txRequestDesc.TxRequestOutputDescs[i]
		abeTxOutputDescs[i] = abecrypto.NewAbeTxOutDesc(txRequestOutputDesc.cryptoAddress, txRequestOutputDesc.value)
	}

	transferTxMsgTemplate, err := abecrypto.CreateTransferTxMsgTemplate(abeTxInputDescs, abeTxOutputDescs, txRequestDesc.TxFee, txRequestDesc.TxMemo)
	if err != nil {
		return nil, nil, err
	}

	transferTxMsg, err := abecrypto.TransferTxGen(abeTxInputDescs, abeTxOutputDescs, transferTxMsgTemplate)
	if err != nil {
		return nil, nil, err
	}

	buf := bytes.NewBuffer(make([]byte, 0, transferTxMsg.SerializeSizeFull()))
	err = transferTxMsg.SerializeFull(buf)
	if err != nil {
		return nil, nil, err
	}

	trTxId := TxId(transferTxMsg.TxId())

	return buf.Bytes(), &trTxId, nil
}
