package abecryptoparam

import (
	"fmt"
	"github.com/cryptosuite/pqringct"
)

// This file is added when refactoring due to the implementation of pqringctx.

// pqringctCryptoAddressParse parse the input cryptoAddress into (serializedAPK, serializedVPK).
// reviewed on 2023.12.07.
// reviewed on 2023.12.12
// reviewed on 2024.01.01
func pqringctCryptoAddressParse(pp *pqringct.PublicParameter, cryptoScheme CryptoScheme, cryptoAddress []byte) (serializedAPK []byte, serializedVPK []byte, err error) {
	//if len(cryptoAddress) < 4 {
	//	return nil, nil, fmt.Errorf("pqringctParseCryptoAddress: invalid length of cryptoAddress: %d", len(cryptoAddress))
	//}

	cryptoSchemeInAddress, err := ExtractCryptoSchemeFromCryptoAddress(cryptoAddress)
	if err != nil {
		return nil, nil, err
	}
	if cryptoSchemeInAddress != cryptoScheme {
		return nil, nil, fmt.Errorf("pqringctParseCryptoAddress: the CryptoScheme of the input cryptoAddress %d does match the input CryptoScheme %d", cryptoSchemeInAddress, cryptoScheme)
	}

	// parse the cryptoAddress to serializedApk and serializedVpk
	apkLen := pqringct.GetAddressPublicKeySerializeSize(pp)
	vpkLen := pqringct.GetValuePublicKeySerializeSize(pp)
	if len(cryptoAddress) != 4+apkLen+vpkLen {
		return nil, nil, fmt.Errorf("pqringctParseCryptoAddress: the input cryptoAddress has invalid length %d", len(cryptoAddress))
	}

	//vpkLen := pp.GetValuePublicKeySerializeSize()
	serializedAPK = cryptoAddress[4 : 4+apkLen]
	serializedVPK = cryptoAddress[4+apkLen:]

	return serializedAPK, serializedVPK, nil
}

// pqringctCryptoSpendSecretKeyParse parse the input cryptoSpendSecretKey, which was generated by CryptoAddressKeyGen or CryptoAddressKeyGenFromSeed,
// to serializedASKSp, i.e., coinSpendSecretKey.
// reviewed on 2023.12.12
func pqringctCryptoSpendSecretKeyParse(pp *pqringct.PublicParameter, cryptoScheme CryptoScheme, cryptoSpendSecretKey []byte) (serializedASKSp []byte, err error) {
	//if len(cryptoSpendSecretKey) < 4 {
	//	return nil, fmt.Errorf("pqringctCryptoSpendSecretKeyParse: invalid length of cryptoSpendSecretKey: %d", len(cryptoSpendSecretKey))
	//}

	cryptoSchemeInSpSk, err := ExtractCryptoSchemeFromCryptoSpsk(cryptoSpendSecretKey)
	if err != nil {
		return nil, err
	}
	if cryptoSchemeInSpSk != cryptoScheme {
		return nil, fmt.Errorf("pqringctCryptoSpendSecretKeyParse: the CryptoScheme of the input cryptoSpendSecretKey %d does match the input CryptoScheme %d", cryptoSchemeInSpSk, cryptoScheme)
	}

	if len(cryptoSpendSecretKey) != 4+pqringct.GetAddressSecretKeySpSerializeSize(pp) {
		return nil, fmt.Errorf("pqringctCryptoSpendSecretKeyParse: the length of the input cryptoSpendSecretKey (%d) does match the input CryptoScheme %d", len(cryptoSpendSecretKey), cryptoScheme)
	}
	// parse the cryptoSpendSecretKey to serializedASKSp
	serializedASKSp = make([]byte, len(cryptoSpendSecretKey)-4)
	copy(serializedASKSp, cryptoSpendSecretKey[4:])

	return serializedASKSp, nil
}

// pqringctCryptoSerialNumberSecretKeyParse parse the input cryptoSnSk, which was generated by CryptoAddressKeyGen or CryptoAddressKeyGenFromSeed,
// to serializedASKSn, i.e., coinSerialNumberKey.
// reviewed on 2023.12.12
func pqringctCryptoSerialNumberSecretKeyParse(pp *pqringct.PublicParameter, cryptoScheme CryptoScheme, cryptoSnSk []byte) (serializedASKSn []byte, err error) {
	cryptoSchemeInSnSk, err := ExtractCryptoSchemeFromCryptoSnsk(cryptoSnSk)
	if err != nil {
		return nil, err
	}
	if cryptoSchemeInSnSk != cryptoScheme {
		return nil, fmt.Errorf("pqringctCryptoSerialNumberSecretKeyParse: the CryptoScheme of the input cryptoSnSk %d does match the input CryptoScheme %d", cryptoSchemeInSnSk, cryptoScheme)
	}

	if len(cryptoSnSk) != 4+pqringct.GetAddressSecretKeySnSerializeSize(pp) {
		return nil, fmt.Errorf("pqringctCryptoSerialNumberSecretKeyParse: the length of the input cryptoSnSk (%d) does match the input CryptoScheme %d", len(cryptoSnSk), cryptoScheme)
	}

	// parse the cryptoSerialNumberSecretKey to serializedASKSn
	serializedASKSn = make([]byte, len(cryptoSnSk)-4)
	copy(serializedASKSn, cryptoSnSk[4:])

	return serializedASKSn, nil
}

// pqringctCryptoValueSecretKeyParse parse the input cryptoValueSecretKey, which was generated by CryptoAddressKeyGen or CryptoAddressKeyGenFromSeed,
// into serializedVsk, i.e., coinValueSecretKey.
// reviewed on 2023.12.12.
func pqringctCryptoValueSecretKeyParse(pp *pqringct.PublicParameter, cryptoScheme CryptoScheme, cryptoValueSecretKey []byte) (serializedVsk []byte, err error) {
	cryptoSchemeInVsk, err := ExtractCryptoSchemeFromCryptoVsk(cryptoValueSecretKey)
	if err != nil {
		return nil, err
	}
	if cryptoSchemeInVsk != cryptoScheme {
		return nil, fmt.Errorf("pqringctCryptoValueSecretKeyParse: the CryptoScheme of the input cryptoValueSecretKey %d does match the input CryptoScheme %d", cryptoValueSecretKey, cryptoScheme)
	}

	if len(cryptoValueSecretKey) != 4+pqringct.GetValueSecretKeySerializeSize(pp) {
		return nil, fmt.Errorf("pqringctCryptoValueSecretKeyParse: the length of input cryptoValueSecretKey (%d) does match the input CryptoScheme %d", len(cryptoValueSecretKey), cryptoScheme)
	}

	// parse the cryptoValueSecretKey to serializedVsk
	serializedVsk = make([]byte, len(cryptoValueSecretKey)-4)
	copy(serializedVsk, cryptoValueSecretKey[4:])

	return serializedVsk, nil
}

func pqringctGetParamSeedBytesLen(pp *pqringct.PublicParameter) int {
	return pqringct.GetParamSeedBytesLen(pp)
}
