package abecrypto

import (
	"errors"
	"fmt"
	"github.com/abesuite/abec/abecrypto/abecryptoparam"
	"github.com/abesuite/abec/chainhash"
	"github.com/abesuite/abec/wire"
)

// data structures for abec side	begin
// AbeTxOutputDesc defines the description for Txo generation
type AbeTxOutputDesc struct {
	cryptoAddress []byte // generated by CryptoAddressKeyGen
	value         uint64
}

func (o *AbeTxOutputDesc) GetValue() uint64 {
	return o.value
}

// AbeTxInputDesc defines the data that are need to spend a TxoCoin, in TransferTxGen
// The fields (ringHash, txoList) are depreciated since 2023.04, replaced with (ringId, txoRing)
type AbeTxInputDesc struct {
	ringHash      chainhash.Hash   // txoRing identifier; depreciated, replaced with ringId
	txoList       []*wire.TxOutAbe // depreciated, replaced with ringId
	ringId        *wire.RingId     // txoRing identifier
	txoRing       *wire.TxoRing    // complete TxoRing information
	sidx          uint8            // spend which one
	cryptoAddress []byte           // address, generated by CryptoAddressKeyGen
	cryptoSpsk    []byte           // spend secret key, generated by CryptoAddressKeyGen
	cryptoSnsk    []byte           //  serial-number secret key, generated by CryptoAddressKeyGen
	cryptoVsk     []byte           //  view secret key, generated by CryptoAddressKeyGen
	value         uint64
}

// AbeTxInDetail defines the data describing a consumed TxoCoin in TransferTx, which will be used in TransferTxVerify
type AbeTxInDetail struct {
	ringHash     chainhash.Hash // txoRing identifier
	txoList      []*wire.TxOutAbe
	serialNumber []byte
}

// Deprecated since 2023.04
func NewAbeTxInputDesc(ringHash chainhash.Hash, txoList []*wire.TxOutAbe,
	sidx uint8, cryptoAddress []byte, cryptoSpsk []byte, cryptoSnsk []byte, cryptoVsk []byte, value uint64) *AbeTxInputDesc {
	return &AbeTxInputDesc{
		ringHash:      ringHash,
		txoList:       txoList,
		sidx:          sidx,
		cryptoAddress: cryptoAddress,
		cryptoSpsk:    cryptoSpsk,
		cryptoSnsk:    cryptoSnsk,
		cryptoVsk:     cryptoVsk,
		value:         value,
	}
}

func NewAbeTxInputDescWithFullRing(ringId *wire.RingId, txoRing *wire.TxoRing,
	sidx uint8, cryptoAddress []byte, cryptoSpsk []byte, cryptoSnsk []byte, cryptoVsk []byte, value uint64) *AbeTxInputDesc {
	return &AbeTxInputDesc{
		ringHash:      chainhash.Hash(*ringId), //	to be compatible with the depreciated
		txoList:       txoRing.TxOuts,          //	to be compatible with the depreciated
		ringId:        ringId,
		txoRing:       txoRing,
		sidx:          sidx,
		cryptoAddress: cryptoAddress,
		cryptoSpsk:    cryptoSpsk,
		cryptoSnsk:    cryptoSnsk,
		cryptoVsk:     cryptoVsk,
		value:         value,
	}
}

func NewAbeTxInDetail(ringHash chainhash.Hash, txoList []*wire.TxOutAbe, serialNumber []byte) *AbeTxInDetail {
	return &AbeTxInDetail{
		ringHash:     ringHash,
		txoList:      txoList,
		serialNumber: serialNumber,
	}
}

func NewAbeTxOutDesc(cryptoAddress []byte, value uint64) *AbeTxOutputDesc {
	return &AbeTxOutputDesc{
		cryptoAddress: cryptoAddress,
		value:         value,
	}
}
func ExtractCoinAddressFromTxoScript(txoscript []byte, cryptoScheme abecryptoparam.CryptoScheme) ([]byte, error) {
	var coinAddr []byte
	var err error
	switch cryptoScheme {
	case abecryptoparam.CryptoSchemePQRingCT:
		coinAddr, err = pqringctExtractCoinAddressFromTxoScript(abecryptoparam.PQRingCTPP, txoscript)
		if err != nil {
			return nil, err
		}
	default:
		return nil, errors.New("unsupported ringct version")
	}
	return coinAddr, nil
}

//	data structures for abec side	end

//	abecrypto, abecryptoparam
//	Address(Key) Generation, Transaction Generation and Verify, pqringctTxoCoinReceive, pqringctTxoCoinSerialNumberGen are handled in abecrypto,
//	as these functions are (bidirectional) bridges between underlying crypto-scheme and abec, namely, will translate teh data structure between crypto-scheme and abec(.wire).
//	GetTxoSerialSizeApprox, GetNullSerialNumber, etc. are handled in abecryptoparam,
//	as these functions are unidirectional, namely, called only by abec(.wire), and call the corresponding APIs in crypto-scheme.
//	The Public Parameters (pointers) for the underlying crypto-schemes are defined in abecryptoparam,
//	since both the functions in abecryptoparam and those in abecrypto needs to use these Public Parameters to call the APIs in the underlying crypto-schemes.
//	abecrypto.go is the entrance that abec uses the crypto-scheme, and will distribute abec's requirements to the corresponding crypto-scheme,
//	by using the corresponding public parameters and sub-package for the corresponding crypto-scheme, e.g., abecrypto.abepqringct.
//	The sub-package for crypto-scheme (e.g., abecrypto.abepqringct) will process the details, say,
//	translate abec's data structures to crypto-scheme's data structures, call crypto-scheme's APIs, translate the result (in crypto-scheme's data structures) to abec's.

// CryptoAddressKeyGen generate AbeCryptoAddress for specified seed and CryptoScheme.
// The caller (normally wallet) needs to specify the CryptoScheme.
// Requirement-by-Design: The underlying crypto-scheme's must put the crypto-scheme (4 bytes = 32 bits) at the head of the
// returned cryptoAddress, cryptoSpsk, cryptoSnsk, and cryptoVsk.
// By such a design, regardless of the real keys of the underlying crypto-scheme, they have to be encapsed to cryptoAddress, cryptoSpsk, cryptoSnsk, and cryptoVsk.
// By such a design, abecrypto directly calls the functions (except CryptoAddressKeyGen) of underlying crypto-scheme by using the cryptoAddress and cryptoKeys generated by CryptoAddressKeyGen,
// and the crypto-scheme will detach the crypto-scheme in the cryptoAddress and cryptoKeys, and make a check.
//
//	At this moment, we are using PQRingCT, which requires the seed to be 128 bytes.
func CryptoAddressKeyGen(seed []byte, cryptoScheme abecryptoparam.CryptoScheme) (retCryptoAddress []byte, retCryptoSpsk []byte, retCryptoSnsk []byte, retCryptoVsk []byte, err error) {
	switch cryptoScheme {
	case abecryptoparam.CryptoSchemePQRingCT:
		cryptoAddress, cryptoSpsk, cryptoSnsk, cryptoVsk, err := pqringctCryptoAddressGen(abecryptoparam.PQRingCTPP, seed, cryptoScheme)
		if err != nil {
			return nil, nil, nil, nil, err
		}
		return cryptoAddress, cryptoSpsk, cryptoSnsk, cryptoVsk, nil

	default:
		return nil, nil, nil, nil, errors.New("CryptoAddressKeyGen: unsupported crypto-scheme")
	}
	//return nil, nil, nil, nil, nil
}

/*
* CryptoAddressKeySeedGen generates a CryptoAddressKeySeed for cryptoScheme.
The returned cryptoAddressKeySeed consists of cryptoScheme (4 bytes) + AddressKeySeed for cryptoScheme
*/
func CryptoAddressKeySeedGen(cryptoScheme abecryptoparam.CryptoScheme) (retCryptoAddressKeySeed []byte, err error) {
	switch cryptoScheme {
	case abecryptoparam.CryptoSchemePQRingCT:
		cryptoAddressKeySeed := pqringctCryptoAddressKeySeedGen(abecryptoparam.PQRingCTPP, cryptoScheme)
		return cryptoAddressKeySeed, nil

	default:
		return nil, errors.New("CryptoAddressSeedKeyGen: unsupported crypto-scheme")
	}
}

func ExtractCryptoSchemeFromCryptoAddressKeySeed(cryptoAddressKeySeed []byte) (cryptoScheme abecryptoparam.CryptoScheme, err error) {
	if len(cryptoAddressKeySeed) < 4 {
		return 0, errors.New("incorrect length of cryptoAddressKeySeed when calling ExtractCryptoSchemeFromCryptoAddressKeySeed")
	}

	return abecryptoparam.DeserializeCryptoScheme(cryptoAddressKeySeed[:4])
}

/*
* CryptoAddressKeyGenFromSeed generates address and key for cryptoScheme from
cryptoAddressKeySeed which is expected to be generated by CryptoAddressKeySeedGen.
In particular, cryptoAddressKeySeed = cryptoScheme (4 bytes) + AddressKeySeed for cryptoScheme.
CryptoAddressKeyGen, which takes input pure AddressKeySeed for cryptoScheme, will be depreciated.
*/
func CryptoAddressKeyGenFromSeed(cryptoAddressKeySeed []byte) (retCryptoAddress []byte, retCryptoSpsk []byte, retCryptoSnsk []byte, retCryptoVsk []byte, err error) {
	cryptoScheme, err := ExtractCryptoSchemeFromCryptoAddressKeySeed(cryptoAddressKeySeed)
	if err != nil {
		return nil, nil, nil, nil, err
	}

	switch cryptoScheme {
	case abecryptoparam.CryptoSchemePQRingCT:
		cryptoAddress, cryptoSpsk, cryptoSnsk, cryptoVsk, err := pqringctCryptoAddressGenFromSeed(abecryptoparam.PQRingCTPP, cryptoAddressKeySeed, cryptoScheme)
		if err != nil {
			return nil, nil, nil, nil, err
		}
		return cryptoAddress, cryptoSpsk, cryptoSnsk, cryptoVsk, nil

	default:
		return nil, nil, nil, nil, errors.New("CryptoAddressKeyGen: unsupported crypto-scheme")
	}
	//return nil, nil, nil, nil, nil
}

func GetCryptoAddressSerializeSize(cryptoScheme abecryptoparam.CryptoScheme) uint32 {
	switch cryptoScheme {
	case abecryptoparam.CryptoSchemePQRingCT:
		return pqringctCryptoAddressSize(abecryptoparam.PQRingCTPP)

	default:
		return 0
	}
}

// GetCryptoAddressSerializeSizeMax returns the max of all possible CryptoAddressSerializeSizes
func GetCryptoAddressSerializeSizeMax() uint32 {
	// todo: when multiple cryptoSchemes are supported, we need to return the max one.
	return pqringctCryptoAddressSize(abecryptoparam.PQRingCTPP)
}

//// ExtractCryptoSchemeFromCryptoAddress extracts cryptoScheme from cryptoAddress
//func ExtractCryptoSchemeFromCryptoAddress(cryptoAddress []byte) (cryptoScheme abecryptoparam.CryptoScheme, err error) {
//	if len(cryptoAddress) < 4 {
//		errStr := fmt.Sprintf("ExtractCryptoSchemeFromCryptoAddress: incorrect length of cryptoAddress: %d", len(cryptoAddress))
//		return 0, errors.New(errStr)
//	}
//
//	return abecryptoparam.Deserialize(cryptoAddress[:4])
//
//}

// CheckCryptoAddress checks whether the input cryptoAddress is well-formed.
func CheckCryptoAddress(cryptoAddress []byte) (valid bool, hints string) {
	cryptoScheme, err := abecryptoparam.ExtractCryptoSchemeFromCryptoAddress(cryptoAddress)
	if err != nil {
		return false, err.Error()
	}

	switch cryptoScheme {
	case abecryptoparam.CryptoSchemePQRingCT:
		return pqringctCheckCryptoAddress(abecryptoparam.PQRingCTPP, cryptoScheme, cryptoAddress)

	default:
		return false, "CheckCryptoAddress: non-supported cryptoScheme appears in cryptoAddress"
	}

	return true, ""
}

//// ExtractCryptoSchemeFromCryptoAddressSpsk extracts cryptoScheme from cryptoAddress
//func ExtractCryptoSchemeFromCryptoAddressSpsk(cryptoSpsk []byte) (cryptoScheme abecryptoparam.CryptoScheme, err error) {
//	if len(cryptoSpsk) < 4 {
//		errStr := fmt.Sprintf("ExtractCryptoSchemeFromCryptoAddressSpsk: incorrect length of cryptoSpsk: %d", len(cryptoSpsk))
//		return 0, errors.New(errStr)
//	}
//
//	return abecryptoparam.Deserialize(cryptoSpsk[:4])
//
//}

//// ExtractCryptoSchemeFromCryptoAddressSnsk extracts cryptoScheme from cryptoAddress
//func ExtractCryptoSchemeFromCryptoAddressSnsk(cryptoSnsk []byte) (cryptoScheme abecryptoparam.CryptoScheme, err error) {
//	if len(cryptoSnsk) < 4 {
//		errStr := fmt.Sprintf("ExtractCryptoSchemeFromCryptoAddressSnsk: incorrect length of cryptoSnsk: %d", len(cryptoSnsk))
//		return 0, errors.New(errStr)
//	}
//
//	return abecryptoparam.Deserialize(cryptoSnsk[:4])
//
//}

//// ExtractCryptoSchemeFromCryptoVsk extracts cryptoScheme from cryptoAddress
//func ExtractCryptoSchemeFromCryptoVsk(cryptoVsk []byte) (cryptoScheme abecryptoparam.CryptoScheme, err error) {
//	if len(cryptoVsk) < 4 {
//		errStr := fmt.Sprintf("ExtractCryptoSchemeFromCryptoVsk: incorrect length of cryptoVsk: %d", len(cryptoVsk))
//		return 0, errors.New(errStr)
//	}
//
//	return abecryptoparam.Deserialize(cryptoVsk[:4])
//
//}

// Note that this layer is responsible for only distribute the call to corresponding underlying crypto schemes.
func VerifyCryptoAddressSpsnsk(cryptoAddress []byte, cryptoSpsk []byte, cryptoSnsk []byte) (valid bool, hints string) {
	cryptoScheme, err := abecryptoparam.ExtractCryptoSchemeFromCryptoAddress(cryptoAddress)
	if err != nil {
		return false, err.Error()
	}

	switch cryptoScheme {
	case abecryptoparam.CryptoSchemePQRingCT:
		return pqringctVerifyCryptoAddressSpsnsk(abecryptoparam.PQRingCTPP, cryptoScheme, cryptoAddress, cryptoSpsk, cryptoSnsk)

	default:
		return false, "VerifyCryptoAddressSpsnsk: non-supported cryptoScheme appears in cryptoAddress"
	}

	return true, ""
}

func VerifyCryptoAddressVsk(cryptoAddress []byte, cryptoVsk []byte) (ok bool, hints string) {
	cryptoScheme, err := abecryptoparam.ExtractCryptoSchemeFromCryptoAddress(cryptoAddress)
	if err != nil {
		return false, err.Error()
	}

	switch cryptoScheme {
	case abecryptoparam.CryptoSchemePQRingCT:
		return pqringctVerifyCryptoAddressVsk(abecryptoparam.PQRingCTPP, cryptoScheme, cryptoAddress, cryptoVsk)

	default:
		return false, "VerifyCryptoAddressVsk: non-supported cryptoScheme appears in cryptoAddress"
	}

	return true, ""
}

// To be self-contained, this function checks the validity of CryptoAddress first.
func VerifyCryptoAddressKey(cryptoAddress []byte, cryptoSpsk []byte, cryptoSnsk []byte, cryptoVsk []byte) (ok bool, hints string) {
	if validTmp, hintsTmp := CheckCryptoAddress(cryptoAddress); !validTmp {
		return false, hintsTmp
	}

	if validTmp, hintsTmp := VerifyCryptoAddressSpsnsk(cryptoAddress, cryptoSpsk, cryptoSnsk); !validTmp {
		return false, hintsTmp
	}

	if validTmp, hintsTmp := VerifyCryptoAddressVsk(cryptoAddress, cryptoVsk); !validTmp {
		return false, hintsTmp
	}

	return true, ""
}

// ExtractCoinAddressFromCryptoAddress is implemented for only the designs where coinAddress is a part of cryptoAddress,
// such as CryptoSchemePQRingCT.
func ExtractCoinAddressFromCryptoAddress(cryptoAddress []byte) ([]byte, error) {
	cryptoScheme, err := abecryptoparam.ExtractCryptoSchemeFromCryptoAddress(cryptoAddress)
	if err != nil {
		return nil, err
	}

	var coinAddr []byte
	switch cryptoScheme {
	case abecryptoparam.CryptoSchemePQRingCT:
		coinAddr, err = pqringctExtractCoinAddressFromCryptoAddress(abecryptoparam.PQRingCTPP, cryptoAddress, cryptoScheme)
		if err != nil {
			return nil, err
		}
	default:
		return nil, errors.New("unsupported cryptoScheme version")
	}
	return coinAddr, nil
}

func CoinbaseTxGen(abeTxOutputDescs []*AbeTxOutputDesc, coinbaseTxMsgTemplate *wire.MsgTxAbe) (*wire.MsgTxAbe, error) {
	cryptoScheme, err := abecryptoparam.GetCryptoSchemeByTxVersion(coinbaseTxMsgTemplate.Version)
	if err != nil {
		return nil, err
	}

	switch cryptoScheme {
	case abecryptoparam.CryptoSchemePQRingCT:
		cbTx, err := pqringctCoinbaseTxGen(abecryptoparam.PQRingCTPP, cryptoScheme, abeTxOutputDescs, coinbaseTxMsgTemplate)
		if err != nil {
			return nil, err
		}
		return cbTx, nil
	default:
		return nil, errors.New("CoinbaseTxGen: Unsupported crypto scheme")
	}

}

// CoinbaseTxVerify
// refactored on 2024.01.06, using err == nil or not to denote valid or invalid.
func CoinbaseTxVerify(coinbaseTx *wire.MsgTxAbe) error {
	cryptoScheme, err := abecryptoparam.GetCryptoSchemeByTxVersion(coinbaseTx.Version)
	if err != nil {
		return err
	}

	switch cryptoScheme {
	case abecryptoparam.CryptoSchemePQRingCT:
		err = pqringctCoinbaseTxVerify(abecryptoparam.PQRingCTPP, coinbaseTx)
		if err != nil {
			return err
		}
	default:
		return fmt.Errorf("CoinbaseTxVerify: Unsupported crypto scheme")
	}

	return nil
}

// CreateTransferTxMsgTemplate creates a *wire.MsgTxAbe template, which will be used when calling TransferTxGen().
// To be self-contained, we put it here, together with TransferTxGen().
// The fields of *wire.MsgTxAbe template will be handled as below:
//
//	(1) Version: filled here
//	(2) TxIns: partially filled here, say filled except the serialNumber
//	(3) TxOuts: set empty here and will be filled by underlying crypto schemes
//	(4) TxFee: filled here
//	(5)	TxMemo: filled here
//	(6) TxWitness: set empty here and will be filled by underlying crypto schemes
//	In summary, CreateTransferTxMsgTemplate() fills all fields except the serialNumber, TxOuts, and TxWitness.
//	Note that these filled fields (except the Version) are independent of the underlying crypto scheme, and are specified by the issuer of a transaction.
//
// abecrypto.CreateTransferTxMsgTemplate will create transaction with version wire.TxVersion_Height_0 which maps to abecryptoparam.CryptoSchemePQRingCT
func CreateTransferTxMsgTemplate(abeTxInputDescs []*AbeTxInputDesc, abeTxOutputDescs []*AbeTxOutputDesc, txFee uint64, txMemo []byte) (*wire.MsgTxAbe, error) {
	//	Version
	// For MLPAUT fork at specified height, the transaction version switch to new one ( wire.TxVersion_Height_MLPAUT_300000 ),
	// here we fix the outdated version (wire.TxVersion_Height_0) used by abecrypto.CreateTransferTxMsgTemplate
	txMsgTemplate := wire.NewMsgTxAbe(wire.TxVersion_Height_0)
	//	Note that new Tx must use the latest/current TxVersion.

	//	TxIns
	for _, txInputDesc := range abeTxInputDescs {
		txIn := wire.NewTxInAbe(nil, txInputDesc.txoRing.OutPointRing)
		txMsgTemplate.AddTxIn(txIn)
	}

	//	TxOuts: skip

	//	TxFee
	txMsgTemplate.TxFee = txFee

	//	TxMemo
	txMsgTemplate.TxMemo = txMemo

	//	TxWitness: skip

	return txMsgTemplate, nil
}

// TransferTxGen() distributes the function to the underlying crypto schemes, according to the TxVersion in the transferTxMsgTemplate.
// Further, the underlying crypto-scheme may distribute the function further based on the input rings' version.
func TransferTxGen(abeTxInputDescs []*AbeTxInputDesc, abeTxOutputDescs []*AbeTxOutputDesc, transferTxMsgTemplate *wire.MsgTxAbe) (*wire.MsgTxAbe, error) {
	cryptoScheme, err := abecryptoparam.GetCryptoSchemeByTxVersion(transferTxMsgTemplate.Version)
	if err != nil {
		return nil, err
	}

	switch cryptoScheme {
	case abecryptoparam.CryptoSchemePQRingCT:
		trTx, err := pqringctTransferTxGen(abecryptoparam.PQRingCTPP, cryptoScheme, abeTxInputDescs, abeTxOutputDescs, transferTxMsgTemplate)
		if err != nil {
			return nil, err
		}
		return trTx, nil
	default:
		return nil, errors.New("TransferTxGen: Unsupported crypto scheme")
	}

}

// TransferTxVerify
// refactored on 2024.01.06, using err == nil or not to denote valid or invalid
func TransferTxVerify(transferTx *wire.MsgTxAbe, abeTxInDetails []*AbeTxInDetail) error {
	cryptoScheme, err := abecryptoparam.GetCryptoSchemeByTxVersion(transferTx.Version)
	if err != nil {
		return err
	}

	switch cryptoScheme {
	case abecryptoparam.CryptoSchemePQRingCT:
		err = pqringctTransferTxVerify(abecryptoparam.PQRingCTPP, transferTx, abeTxInDetails)
		if err != nil {
			return err
		}
	default:
		return fmt.Errorf("TransferTxVerify: Unsupported crypto scheme")
	}

	return nil
}

// TxoCoinReceive checks whether a Txo/Coin belongs to the input cryptoAddress, and return the value if true.
// cryptoAddress/serializedSkvalue is the cryptoAddress/serializedSkvalue generated by the CryptoAddressKeyGen() algorithm,
// and what the format is depends on the underlying crypto-scheme.
// For example, for the current CryptoSchemePQRingCT (which does not suppose stealth cryptoAddress), abecryptoAddress is an Instance Address,
// while for a future version supporting stealth cryptoAddress, cryptoAddress could be a master public key (master cryptoAddress).
func TxoCoinReceive(abeTxo *wire.TxOutAbe, cryptoAddress []byte, cryptoVsk []byte) (bool, uint64, error) {
	cryptoScheme, err := abecryptoparam.GetCryptoSchemeByTxVersion(abeTxo.Version)
	if err != nil {
		return false, 0, err
	}

	switch cryptoScheme {
	case abecryptoparam.CryptoSchemePQRingCT:
		valid, value, err := pqringctTxoCoinReceive(abecryptoparam.PQRingCTPP, cryptoScheme, abeTxo, cryptoAddress, cryptoVsk)
		if err != nil {
			return false, 0, err
		}
		return valid, value, nil

	default:
		return false, 0, errors.New("TxoCoinReceive: unsupported crypto scheme")
	}
}

// Abec uses the fixed-ring mechanism, and uses (ringHash, index) as the uniqe identifier of Txo in blockchain.
// cryptoSnsk was generated by the CryptoAddressKeyGen() algorithm,
// and what the format is depends on the underlying crypto-scheme.
func TxoCoinSerialNumberGen(txo *wire.TxOutAbe, ringHash chainhash.Hash, txoIndexInRing uint8, cryptoSnsk []byte) ([]byte, error) {
	cryptoScheme, err := abecryptoparam.GetCryptoSchemeByTxVersion(txo.Version)
	if err != nil {
		return nil, err
	}

	switch cryptoScheme {
	case abecryptoparam.CryptoSchemePQRingCT:
		sn, err := pqringctTxoCoinSerialNumberGen(abecryptoparam.PQRingCTPP, abecryptoparam.CryptoSchemePQRingCT, txo, ringHash, txoIndexInRing, cryptoSnsk)
		if err != nil {
			return nil, err
		}
		return sn, nil

	default:
		return nil, errors.New("TxoCoinSerialNumberGen: Unsupported crypto scheme")
	}
}

//
//func TxoSerialNumberGen(txo *wire.TxOutAbe, ringHash chainhash.Hash, serializedSksn []byte) []byte {
//	var sn []byte
//
//	cryptoScheme := abecryptoparam.GetCryptoSchemeByTxVersion(txo.Version)
//
//	switch cryptoScheme {
//	case abecryptoparam.CryptoSchemePQRingCT:
//		// parse cryptoAddress -> cryptoAddress public key and value public key
//		sn = TxoSerialNumberGen(abecryptoparam.PQRingCTPP, txo, ringHash, serializedSksn)
//	default:
//		log.Fatalln("Unsupported crypto scheme ")
//	}
//	return sn
//}
