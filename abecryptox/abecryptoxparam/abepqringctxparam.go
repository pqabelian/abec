package abecryptoxparam

import (
	"errors"
	"fmt"
	"github.com/cryptosuite/pqringctx/pqringctxapi"
)

//	APIs for AddressKey-Encode-Format	begin

// pqringctxCryptoAddressParse parses the input cryptoAddress into (coinAddress, valuePublicKey), where valuePublicKey may be nil.
// Note that cryptoAddress was generated by pqringctxCryptoAddressKeyGen, where, depending on the privacyLevel,
// cryptoAddress = cryptoScheme (4 bytes) + privacyLevel (1 byte) + coinAddress or
// cryptoAddress = cryptoScheme (4 bytes) + privacyLevel (1 byte) + coinAddress + valuePublicKey
// Note that this function will parse only those cryptoAddresses generated by pqringctxCryptoAddressKeyGen.
// Note that this is the only function at the pqringctxABC level that takes cryptoAddress as input.
// The caller will call this function and (possible) other APIs (e.g., the ones in abecrypto for back-compatability) to parse cryptoAddress to coinAddress,
// and the call other functions with coinAddress as the input.
// pqringctxCryptoAddressParse parse the cryptoAddress generated by pqringctxCryptoAddressKeyGen.
func pqringctxCryptoAddressParse(pp *pqringctxapi.PublicParameter, cryptoScheme CryptoScheme, cryptoAddress []byte) (
	privacyLevel PrivacyLevel,
	coinAddress []byte,
	valuePublicKey []byte,
	err error) {
	cryptoSchemeInCryptoAddress, err := ExtractCryptoSchemeFromCryptoAddress(cryptoAddress)
	if err != nil {
		return 0, nil, nil, err
	}

	if cryptoSchemeInCryptoAddress != cryptoScheme {
		return 0, nil, nil, errors.New("pqringctxCryptoAddressParse: the input cryptoScheme does not match the cryptoScheme extracted from the input coinAddress")
	}

	if len(cryptoAddress) < 5 {
		errStr := fmt.Sprintf("pqringctxCryptoAddressParse: incorrect length of cryptoAddress: %d", len(cryptoAddress))
		return 0, nil, nil, errors.New(errStr)
	}

	privacyLevel = PrivacyLevel(cryptoAddress[4])

	if privacyLevel == PrivacyLevelRINGCT {
		coinAddressSize, err := pqringctxapi.GetCoinAddressSizeByCoinAddressKeyForRingGen(pp)
		if err != nil {
			return 0, nil, nil, err
		}
		coinValuePublicSize := pqringctxapi.GetCoinValuePublicKeySize(pp)

		if len(cryptoAddress) != 5+coinAddressSize+coinValuePublicSize {
			errStr := fmt.Sprintf("pqringctxCryptoAddressParse: incorrect length of cryptoAddress: %d for privacyLevel = %d", len(cryptoAddress), privacyLevel)
			return 0, nil, nil, errors.New(errStr)
		}

		coinAddress = make([]byte, coinAddressSize)
		copy(coinAddress, cryptoAddress[5:5+coinAddressSize])

		valuePublicKey = make([]byte, coinValuePublicSize)
		copy(valuePublicKey, cryptoAddress[5+coinAddressSize:])

		return privacyLevel, coinAddress, valuePublicKey, nil

	} else if privacyLevel == PrivacyLevelPSEUDONYM {
		coinAddressSize, err := pqringctxapi.GetCoinAddressSizeByCoinAddressKeyForSingleGen(pp)
		if err != nil {
			return 0, nil, nil, err
		}

		if len(cryptoAddress) != 5+coinAddressSize {
			errStr := fmt.Sprintf("pqringctxCryptoAddressParse: incorrect length of cryptoAddress: %d for privacyLevel = %d", len(cryptoAddress), privacyLevel)
			return 0, nil, nil, errors.New(errStr)
		}

		coinAddress = make([]byte, coinAddressSize)
		copy(coinAddress, cryptoAddress[5:])

		valuePublicKey = nil

		return privacyLevel, coinAddress, valuePublicKey, nil

	} else {
		errStr := fmt.Sprintf("pqringctxCryptoAddressParse: invalid PrivacyLevel of cryptoAddress: %d", byte(privacyLevel))
		return 0, nil, nil, errors.New(errStr)
	}

	return 0, nil, nil, nil
}

// APIs for AddressKey-Encode-Format	end

// API for Sizes	begin
func pqringctxGetCryptoSchemeParamSeedBytesLen(pp *pqringctxapi.PublicParameter) int {
	return pqringctxapi.GetParamSeedBytesLen(pp)
}

func pqringctxGetTxoSerializeSize(pp *pqringctxapi.PublicParameter, coinAddress []byte) (int, error) {
	return pqringctxapi.GetTxoSerializeSize(pp, coinAddress)
}

func pqringctxGetCbTxWitnessSerializeSize(pp *pqringctxapi.PublicParameter, coinAddressListPayTo [][]byte) (int, error) {
	return pqringctxapi.GetCbTxWitnessSerializeSizeByDesc(pp, coinAddressListPayTo)
}

//	API for Sizes	end

// GetNullSerialNumber() return the null serial number.
func pqringctxGetNullSerialNumber(pp *pqringctxapi.PublicParameter) []byte {
	return pqringctxapi.GetNullSerialNumber(pp)
}
