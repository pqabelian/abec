package abecryptoxparam

import (
	"errors"
	"fmt"
	"github.com/cryptosuite/pqringctx/pqringctxapi"
)

//	APIs for AddressKey-Encode-Format	begin

// pqringctxCryptoAddressParse parses the input cryptoAddress into (coinAddress, valuePublicKey), where valuePublicKey may be nil.
// Note that cryptoAddress was generated by pqringctxCryptoAddressKeyGen, where, depending on the privacyLevel,
// cryptoAddress = cryptoScheme (4 bytes) + privacyLevel (1 byte) + coinAddress or
// cryptoAddress = cryptoScheme (4 bytes) + privacyLevel (1 byte) + coinAddress + valuePublicKey
func pqringctxCryptoAddressParse(pp *pqringctxapi.PublicParameter, cryptoScheme CryptoScheme, cryptoAddress []byte) (
	privacyLevel PrivacyLevel,
	coinAddress []byte,
	valuePublicKey []byte,
	err error) {
	cryptoSchemeInCryptoAddress, err := ExtractCryptoSchemeFromCryptoAddress(cryptoAddress)
	if err != nil {
		return 0, nil, nil, err
	}

	if cryptoSchemeInCryptoAddress != cryptoScheme {
		return 0, nil, nil, errors.New("pqringctxCryptoAddressParse: the input cryptoScheme does not match the cryptoScheme extracted from the input coinAddress")
	}

	if len(cryptoAddress) < 5 {
		errStr := fmt.Sprintf("pqringctxCryptoAddressParse: incorrect length of cryptoAddress: %d", len(cryptoAddress))
		return 0, nil, nil, errors.New(errStr)
	}

	privacyLevel = PrivacyLevel(cryptoAddress[4])

	if privacyLevel == PrivacyLevelRINGCT {
		coinAddressSize, err := pqringctxapi.GetCoinAddressSizeByCoinAddressKeyForRingGen(pp)
		if err != nil {
			return 0, nil, nil, err
		}
		coinValuePublicSize := pqringctxapi.GetCoinValuePublicKeySize(pp)

		if len(cryptoAddress) != 5+coinAddressSize+coinValuePublicSize {
			errStr := fmt.Sprintf("pqringctxCryptoAddressParse: incorrect length of cryptoAddress: %d for privacyLevel = %d", len(cryptoAddress), privacyLevel)
			return 0, nil, nil, errors.New(errStr)
		}

		coinAddress = make([]byte, coinAddressSize)
		copy(coinAddress, cryptoAddress[5:5+coinAddressSize])

		valuePublicKey = make([]byte, coinValuePublicSize)
		copy(valuePublicKey, cryptoAddress[5+coinAddressSize:])

		return privacyLevel, coinAddress, valuePublicKey, nil

	} else if privacyLevel == PrivacyLevelPSEUDONYM {
		coinAddressSize, err := pqringctxapi.GetCoinAddressSizeByCoinAddressKeyForSingleGen(pp)
		if err != nil {
			return 0, nil, nil, err
		}

		if len(cryptoAddress) != 5+coinAddressSize {
			errStr := fmt.Sprintf("pqringctxCryptoAddressParse: incorrect length of cryptoAddress: %d for privacyLevel = %d", len(cryptoAddress), privacyLevel)
			return 0, nil, nil, errors.New(errStr)
		}

		coinAddress = make([]byte, coinAddressSize)
		copy(coinAddress, cryptoAddress[5:])

		valuePublicKey = nil

		return privacyLevel, coinAddress, valuePublicKey, nil

	} else {
		errStr := fmt.Sprintf("pqringctxCryptoAddressParse: invalid PrivacyLevel of cryptoAddress: %d", byte(privacyLevel))
		return 0, nil, nil, errors.New(errStr)
	}

	return 0, nil, nil, nil
}

// APIs for AddressKey-Encode-Format	end

// API for Sizes	begin
func pqringctxGetCryptoSchemeParamSeedBytesLen(pp *pqringctxapi.PublicParameter) int {
	return pqringctxapi.GetParamSeedBytesLen(pp)
}

func pqringctxGetTxoSerializeSizeApprox(pp *pqringctxapi.PublicParameter, cryptoAddress []byte) (int, error) {
	_, coinAddress, _, err := pqringctxCryptoAddressParse(pp, CryptoSchemePQRingCTX, cryptoAddress)
	if err != nil {
		return 0, err
	}
	pqringctxapi.GetTxoSerializeSizeApprox(pp, coinAddress)
	return 0, nil
	// pqringctxapi.GetTxoSerializeSizeApprox(PQRingCTXPP, coinAddress)
}

func pqringctxGetCbTxWitnessSerializeSizeApprox(pp *pqringctxapi.PublicParameter, cryptoAddressListPayTo [][]byte) (int, error) {
	return 0, nil
}

//	API for Sizes	end
